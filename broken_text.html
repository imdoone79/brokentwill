<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Broken Twill — Text Write-On (with Beep & Pluck)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
  html,body{height:100%;margin:0;background:#0a0a0a;color:#eaeaea;font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Pretendard,Arial}
  header{position:fixed;left:16px;top:16px;display:flex;gap:10px;z-index:10}
  #ui{position:fixed;right:16px;top:16px;display:flex;gap:8px;align-items:center;z-index:10;background:#141414;border:1px solid #2a2a2a;padding:8px 10px;border-radius:12px}
  .btn{appearance:none;border:1px solid #2a2a2a;background:#141414;color:#eaeaea;padding:10px 12px;border-radius:10px;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  input[type="text"]{background:#0f0f0f;border:1px solid #2a2a2a;color:#eaeaea;border-radius:8px;padding:8px 10px;min-width:160px}
  label{font-size:12px;color:#a6adb3}
  .range{display:flex;gap:8px;align-items:center}
  .range input{width:120px}
  main{display:grid;place-items:center;min-height:100vh}
  canvas{box-shadow:0 0 0 1px #1e1e1e inset;border-radius:12px;background:#0c0c0c}
</style>
</head>
<body>
<header>
  <button id="playBtn" class="btn">Play</button>
  <button id="resetBtn" class="btn">Reset</button>
</header>

<div id="ui">
  <input id="textInput" type="text" value="UNIFORM" title="텍스트를 바꾸고 Reset 후 Play하세요"/>
  <div class="range"><label>밀도</label><input id="dens" type="range" min="8" max="40" step="1" value="20"></div>
  <div class="range"><label>두께</label><input id="thick" type="range" min="0.5" max="3" step="0.1" value="1.2"></div>
  <div class="range"><label>각도</label><input id="ang" type="range" min="20" max="70" step="1" value="38"></div>
</div>

<main></main>

<script>
/* ===== 기본 파라미터 ===== */
const WIDTH=1920, HEIGHT=1080, FPS=30;
const WRITE_DURATION = 6.0;   // 글자 쓰이는 시간(초)
const HOLD_AT_END    = 1.0;   // 끝에서 정지 시간(초)
const BG_HOVER       = 0.35;  // 배경 잔잔함 정도(0~1)

let frameAbs=0, running=false, startedAudio=false;
let tStart=0, progress=0;     // 0..1
let lastBin=-1;               // 사운드 트리거 위한 진행도 bin

/* ===== 유틸 ===== */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function lerp(a,b,t){return a+(b-a)*t;}
function random(a,b){return a + Math.random()*(b-a);}

/* ===== 색과 그라디언트 ===== */
function hsb(h,s,b,a){s/=100;b/=100;const C=b*s,hh=(h/60)%6,X=C*(1-Math.abs(hh%2-1));
let r=0,g=0,bl=0;if(0<=hh&&hh<1){r=C;g=X;}else if(1<=hh&&hh<2){r=X;g=C;}
else if(2<=hh&&hh<3){g=C;bl=X;}else if(3<=hh&&hh<4){g=X;bl=C;}
else if(4<=hh&&hh<5){r=X;bl=C;}else{r=C;bl=X;}const m=b-C;
r=Math.round((r+m)*255);g=Math.round((g+m)*255);bl=Math.round((bl+m)*255);return `rgba(${r},${g},${bl},${a})`;}
function gradRect(g,x,y,w,h,r,H,S,B,A,mode){
  const ctx=g.drawingContext;const gx0=x,gy0=y,gx1=(mode==='h')?x+w:x,gy1=(mode==='h')?y:y+h;
  const c0=hsb(H,S,B,A),c1=hsb(H,S,B*0.88,A*0.22);
  const grad=ctx.createLinearGradient(gx0,gy0,gx1,gy1);grad.addColorStop(0,c0);grad.addColorStop(1,c1);
  ctx.save();ctx.beginPath();
  if(typeof ctx.roundRect==='function') ctx.roundRect(x,y,w,h,r);
  else {const rr=Math.min(r,Math.min(w,h)/2);
    ctx.moveTo(x+rr,y);ctx.lineTo(x+w-rr,y);ctx.arc(x+w-rr,y+rr,rr,-Math.PI/2,0);
    ctx.lineTo(x+w,y+h-rr);ctx.arc(x+w-rr,y+h-rr,rr,0,Math.PI/2);
    ctx.lineTo(x+rr,y+h);ctx.arc(x+rr,y+h-rr,rr,Math.PI/2,Math.PI);
    ctx.lineTo(x,y+rr);ctx.arc(x+rr,y+rr,rr,Math.PI,1.5*Math.PI);}
  ctx.fillStyle=grad;ctx.fill();ctx.restore();
}

/* ===== 텍스트 마스크 & 직조 라인 레이어 ===== */
let textMask; let textStr="UNIFORM";
const TEXT_FADE_SHAPE = (p)=>{ // 0..1 -> 0..1(가시성), 약간의 곡선
  // 나타날 땐 빠르게 → 천천히, 막바지에 부드럽게
  return Math.pow(clamp(p,0,1), 0.85);
};
function makeTextMask(){
  textMask = createGraphics(WIDTH, HEIGHT);
  textMask.pixelDensity(1);
  textMask.clear();
  textMask.textAlign(CENTER,CENTER);
  const maxW = WIDTH*0.8;
  const baseSize = Math.min(HEIGHT*0.42, maxW/(Math.max(1,textStr.length)*0.6));
  textMask.textSize(baseSize);
  textMask.noStroke(); textMask.fill(255);
  textMask.text(textStr, WIDTH/2, HEIGHT/2);
}
function insideMask(x,y){ const c = textMask.get(Math.floor(x), Math.floor(y)); return c[3] > 128; }

/* ===== UI ===== */
const densEl  = document.getElementById('dens');
const thickEl = document.getElementById('thick');
const angEl   = document.getElementById('ang');
document.getElementById('textInput').addEventListener('change', e=>{
  textStr = (e.target.value||"").toString().trim() || " ";
  makeTextMask();
});
const playBtn  = document.getElementById('playBtn');
const resetBtn = document.getElementById('resetBtn');

playBtn.onclick = async ()=>{
  if(!startedAudio){ await startAudio(); startedAudio=true; }
  running = !running;
  if(running){
    // 계속 재생(일시정지에서 이어서)
    tStart = millis()/1000 - progress*WRITE_DURATION;
    playBtn.textContent = 'Pause';
  }else{
    playBtn.textContent = 'Play';
    Tone.Transport.pause();
  }
};
resetBtn.onclick = ()=>{
  progress=0; lastBin=-1; tStart = millis()/1000;
  if(!startedAudio){ /* do nothing */ }
  playBtn.textContent = running ? 'Pause' : 'Play';
};

/* ===== p5 ===== */
let gfx, BG={phase:0,rot:0};
const BG_CFG={sMin:0.02,sMax:0.07,rMin:0.002,rMax:0.018,baseS:1.08,baseR:0.20};

function setup(){
  frameRate(FPS);
  const cnv = createCanvas(WIDTH,HEIGHT);
  cnv.parent(document.querySelector('main'));
  gfx=createGraphics(WIDTH,HEIGHT);
  noSmooth();
  makeTextMask();

  // 초기 상태
  running=false; progress=0; lastBin=-1;
}

function draw(){
  const now = millis()/1000;
  if(running){
    progress = clamp((now - tStart)/WRITE_DURATION, 0, 1);
  }
  // 끝까지 쓰인 뒤 HOLD
  if(progress>=1){
    if(now - (tStart + WRITE_DURATION) >= HOLD_AT_END){
      running = false; playBtn.textContent='Play';
      Tone.Transport.pause(); // 소리도 정지
    }
  }

  // 1) 바탕 브로큰 트윌(간결 버전)
  renderTwill(gfx, now);

  // 2) 텍스트 직조 레이어 (교차 선분으로 글자 쓰이기)
  drawTextWeaveLayer(gfx, progress);

  // 3) 배경 미세 스케일/회전
  const sAmp=lerp(BG_CFG.sMin,BG_CFG.sMax,BG_HOVER);
  const rAmp=lerp(BG_CFG.rMin,BG_CFG.rMax,BG_HOVER);
  BG.phase += 0.04*(BG_CFG.baseS + (noise(now*0.2)*2-1)*0.5);
  BG.rot   += 0.015*(BG_CFG.baseR + (noise(now*0.2+10)*2-1)*0.5);
  const sc=1.0 + sAmp*Math.sin(BG.phase);
  const rot=rAmp*Math.sin(BG.rot);

  push(); translate(WIDTH/2,HEIGHT/2); rotate(rot); scale(sc,sc);
  imageMode(CENTER); image(gfx,0,0,WIDTH,HEIGHT); imageMode(CORNER); pop();

  frameAbs++;
}

/* ===== 바탕 트윌 렌더 ===== */
function renderTwill(g,t){
  g.push(); g.clear(); g.colorMode(HSB,360,100,100,1);
  const breakBase=0.25 + 0.1*Math.sin(t*0.6);
  const cellBase=18, cell= cellBase*(1.0+0.18*breakBase);
  const cols=Math.ceil(WIDTH/cell)+2, rows=Math.ceil(HEIGHT/cell)+2;
  const hue0=lerp(210,18,0.12+0.55*breakBase);
  const sat0=lerp(24,56,0.5+0.5*breakBase);
  const bri0=90 + 6*breakBase;

  for(let r=0;r<rows;r++){
    const flipPeriod=Math.max(1,Math.round(8*(0.25+0.55*(1-breakBase))));
    const dir=(r%flipPeriod)<1?1:-1;
    for(let c=0;c<cols;c++){
      const x=c*cell, y=r*cell, warpTop=((c+dir*r)%2)===0;
      const H=(hue0 + (noise(c*0.11,r*0.13)-0.5)*14 + 360)%360;
      const S=sat0*(warpTop?1:0.93), B=bri0*(warpTop?1:0.95);
      const w=warpTop?cell*0.94:cell, h=warpTop?cell:cell*0.94;
      gradRect(g,x,y,w,h,Math.min(w,h)*0.12,H,S,B,0.94,warpTop?'h':'v');
    }
  }
  g.pop();
}

/* ===== 텍스트를 “직조선 교차”로 그리기 (write-on) ===== */
function drawTextWeaveLayer(g, prog){
  const ctx=g.drawingContext;
  const spacing   = parseInt(densEl.value,10);     // 격자 간격
  const thickness = parseFloat(thickEl.value);     // 선 두께
  const angDeg    = parseFloat(angEl.value);       // 교차 각

  const vis = TEXT_FADE_SHAPE(prog);               // 0..1
  if(vis<=0) return;

  // 사운드 트리거: 진행 5% 단위로 비프+플럭
  const bin = Math.floor(prog*20);  // 0..20
  if(bin!==lastBin){
    lastBin=bin;
    triggerWriteSound(bin);
  }

  // 선 길이/밀도
  const L = spacing * (0.9 + 0.6*vis);
  const jitter = spacing*0.35*(0.3+0.7*vis);
  const color = `rgba(8,10,12,${0.65*vis})`; // 진회색
  ctx.save();
  ctx.lineCap='round';
  ctx.strokeStyle=color;
  ctx.lineWidth=thickness;

  const a = angDeg * Math.PI/180;   // +θ
  const b = -angDeg * Math.PI/180;  // –θ

  // 격자 스캔 — 글자 내부에서만 선분 그리기
  for(let y=spacing*0.5; y<HEIGHT; y+=spacing){
    for(let x=spacing*0.5; x<WIDTH; x+=spacing){
      if(!insideMask(x,y)) continue;

      // write-on 느낌: 진행도에 따라 일부만 샘플
      // 확률적으로 vis 비율만큼만 드로우
      if(Math.random() > vis) continue;

      const jx = (Math.random()*2-1)*jitter;
      const jy = (Math.random()*2-1)*jitter;

      // +θ
      let x1 = x + jx - Math.cos(a)*L*0.5;
      let y1 = y + jy - Math.sin(a)*L*0.5;
      let x2 = x + jx + Math.cos(a)*L*0.5;
      let y2 = y + jy + Math.sin(a)*L*0.5;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

      // –θ (가끔 빠지는 올)
      if(Math.random() > 0.08){
        x1 = x + jx - Math.cos(b)*L*0.5;
        y1 = y + jy - Math.sin(b)*L*0.5;
        x2 = x + jx + Math.cos(b)*L*0.5;
        y2 = y + jy + Math.sin(b)*L*0.5;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }
    }
  }
  ctx.restore();
}

/* ===== 오디오: 비프 + 플럭 ===== */
let master, vol, pluck;
async function startAudio(){
  await Tone.start(); await Tone.getContext().resume();
  vol = new Tone.Volume(-6).toDestination();
  master = new Tone.Gain(1).connect(vol);

  // Pluck
  pluck = new Tone.PluckSynth({
    attackNoise:1.2, dampening:3200, resonance:0.98
  }).connect(master);

  // Transport 시작(우린 수동 트리거지만 정책상 시작해두면 안정적)
  Tone.Transport.bpm.value=96;
  Tone.Transport.start();
}
function triggerWriteSound(stepIdx){
  if(!master) return;
  // 비프 주파수는 저→중→고로 조금씩
  const baseFreq = [330, 392, 440, 494, 523, 587, 659, 698, 784][stepIdx % 9];
  quickBeep(baseFreq);
  // 플럭 음고도 살짝 올라가도록
  const notes = ["C4","D4","E4","G4","A4","B4","C5","D5","E5"];
  pluck.triggerAttack(notes[stepIdx % notes.length], "+0.00", 0.85);
}
function quickBeep(freq){
  const osc = new Tone.Oscillator(freq,"sine");
  const env = new Tone.AmplitudeEnvelope({attack:0.005,decay:0.08,sustain:0,release:0.05});
  osc.connect(env).connect(master);
  osc.start();
  env.triggerAttackRelease("16n");
  osc.stop("+0.20");
}
</script>
</body>
</html>
